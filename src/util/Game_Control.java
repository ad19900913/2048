package util;
import java.util.ArrayList;

import model.Block;
import view.Panel_2048;

/*
 * 方块移动时的策略   分为两大步1.跨越空白格  2.融合
 * 方块B向某个方向上移动，如果该方向上下一步为空，则互相交换数值
 * 								     下一步碰到边界，不动
 *                          	     下一步碰到方块如果数值不同，不动
 *                          				       如果数值相同，融合 
 *                         	 	  	
 */
public class Game_Control {
	public static int direction;//移动方向
	public static boolean anyblock_move=false;
	private static int x,y;//表示当前自动填充数字的方块坐标，每次移动后刷新
	private static ArrayList<Integer> mergeIndicator= new ArrayList<Integer>();
	
	
	/*
	 * 此方法是合法移动后才会执行的
	 * 如果在按键方向上没有任何方块被移动，则不会生成新方块
	 * flag用来标识这次移动是不是有效的移动
	 */
	public static boolean setBlock(boolean flag){
			if (flag) {
				//只找一次可能找不到合适的空格来赋值，所以循环
				while (true) {
					x = (int) (Math.random() * 4 + 1);
					y = (int) (Math.random() * 4 + 1);
					for (Block block : Panel_2048.blocks) {
						if (block.x == x && block.y == y && block.value == 0) {
							block.value = 2;
							Recorder.USEFULL_MOVE_TIMES++;
							mergeIndicator=new ArrayList<Integer>();
							anyblock_move = false;
							return true;
						}
					}
				}
			}
			return false;	
	}
	
	//交换的时候只需要交换VALUE
	public static void exchange(Block b1,Block b2){
			b2.value=b1.value;
			b1.value=0;
	}
	/*
	 * b1向b2融合
	 * 但是在一次移动中
	 * 每一行或者每一列只能有一次融合
	 * 
	 */
	public static void merge(Block b1,Block b2){
		
		if(!mergeIndicator.contains(b1.value)){
			/*
			 * 下面这段代码要实现的功能是记录融合发生时的 行 或者 列
			 */
			int val = 0;
			switch (direction) {
			case 1:
			case 2:
				val = b1.x;
				break;
			case 3:
			case 4:
				val=b1.y;
				break;
			}
			mergeIndicator.add(val);
			
			Recorder.SCORES=Recorder.SCORES+2*b2.value;
			b1.value=0;
			b2.value=2*b2.value;
		}
		
	}
	//找到下一块特定坐标的砖块，与方向有关
	public static Block getBlock(Block block,int dir){
		int targetX=block.x;//用来标识要找的目标块的坐标
		int targetY=block.y;
			switch (dir) {
			case 1:
				while (getBlock(targetX, targetY-1).value==0) {
					targetY-=1;
					//进入while循环意味着方块至少移动了一次  
					anyblock_move=true;
				}
				return getBlock(targetX, targetY);
			case 2:
				while (getBlock(targetX, targetY+1).value==0) {
					targetY+=1;
					anyblock_move=true;
				}
				return getBlock(targetX, targetY);
			case 3:
				while (getBlock(targetX-1, targetY).value==0) {
					targetX-=1;
					anyblock_move=true;
				}
				return getBlock(targetX, targetY);
			case 4:
				while (getBlock(targetX+1, targetY).value==0) {
					targetX+=1;
					anyblock_move=true;
				}
				return getBlock(targetX, targetY);
			}
		return null;
	}
	
	//获取特定坐标的Block对象
	public static Block getBlock(int x,int y){
		for (Block block_1 : Panel_2048.blocks){
			if (block_1.x==x&&block_1.y==y) {
				return block_1;
			}
		}
		Block temp=new Block(5, 5);
		temp.value=100;
		return temp;
	}
	
	//处理方块运动的方法
	public static void move(int direction){
		anyblock_move = false;
		/*
		 * 下面是对于每一个有数字的方块进行尝试移动
		 * 要实现一次按键可以使得方块从最左边移动到最右边，
		 *  
		 * 而且需要注意的是 一次有效的移动过程中  每一行或者每一列上最好只能有一次
		 * 数值相同的融合，否则游戏难度会降低。
		 * 就是 2 2 4 8        移动后应该变成
		 *     0 4 4 8        而不是直接变成
		 *     0 0 0 16
		 *           
		 */
		//如果向上移动，那么是从最上面一行开始逐行往下计算 方块的移动
		if(direction==1){
			for (int j = 1; j < 5; j++) {
				for (int j2 = 1; j2 < 5; j2++) {
					Block block_1=getBlock(j2, j);
					if (block_1.value!=0) {//只尝试移动有数值的方块
						/*
						 * 下面一步应该能够跨越方块  比如向右的移动中  
						 * 能从 2 0 0 4 的2直接移动成 0 0 2 4 的格局 
						 * 实现一次性移动两格
						 * 下面这一句的功能是直接定位
						 */
						Block block_2 = getBlock(block_1, direction);
						//先交换一下，在处理
						if (!block_1.equals(block_2)) {
							exchange(block_1, block_2);//交换完成后主块变成block_2
							anyblock_move = true;
						}
						
						Block temp=getBlock(block_2.x,block_2.y-1);
						if (block_2.value == temp.value) {
							merge(block_2, temp);
							anyblock_move = true;
						}
					}
				}
			}	
		}
		
		if(direction==2){
			for (int j = 4; j > 0; j--) {
				for (int j2 = 1; j2 < 5; j2++) {
					Block block_1=getBlock(j2, j);
					if (block_1.value!=0) {//只尝试移动有数值的方块
						Block block_2 = getBlock(block_1, direction);
						if (!block_1.equals(block_2)) {
							exchange(block_1, block_2);//交换完成后主块变成block_2
							anyblock_move = true;
						}
						
						Block temp=getBlock(block_2.x,block_2.y+1);
						if (block_2.value == temp.value) {
							merge(block_2, temp);
							anyblock_move = true;
						}
					}
				}
			}
		}
		
		if(direction==4){
			for (int j = 4; j > 0; j--) {
				for (int j2 = 1; j2 < 5; j2++) {
					Block block_1=getBlock(j, j2);
					if (block_1.value!=0) {//只尝试移动有数值的方块
						Block block_2 = getBlock(block_1, direction);
						if (!block_1.equals(block_2)) {
							exchange(block_1, block_2);//交换完成后主块变成block_2
							anyblock_move = true;
						}
						
						Block temp=getBlock(block_2.x+1,block_2.y);
						if (block_2.value == temp.value) {
							merge(block_2, temp);
							anyblock_move = true;
						}
					}
				}
			}
		}
		
		if(direction==3){
			for (int j = 1; j < 5; j++) {
				for (int j2 = 1; j2 < 5; j2++) {
					Block block_1=getBlock(j, j2);
					if (block_1.value!=0) {//只尝试移动有数值的方块
						Block block_2 = getBlock(block_1, direction);
						if (!block_1.equals(block_2)) {
							exchange(block_1, block_2);//交换完成后主块变成block_2
							anyblock_move = true;
						}
						
						Block temp=getBlock(block_2.x-1,block_2.y);
						if (block_2.value == temp.value) {
							merge(block_2, temp);
							anyblock_move = true;
						}
					}
				}
			}
		}
	}
	
}
